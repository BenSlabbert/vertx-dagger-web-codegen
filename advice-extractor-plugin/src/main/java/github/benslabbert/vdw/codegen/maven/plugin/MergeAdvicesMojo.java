/* Licensed under Apache-2.0 2025. */
package github.benslabbert.vdw.codegen.maven.plugin;

import static java.nio.charset.StandardCharsets.UTF_8;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import java.util.Set;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import org.apache.maven.artifact.Artifact;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.plugins.annotations.ResolutionScope;
import org.apache.maven.project.MavenProject;

/**
 * Extracts all files starting with "advice_" from META-INF directories in all dependency JARs and
 * merges them into a single file. Runs after compilation to capture files generated by annotation
 * processors.
 */
@Mojo(
    name = "merge-advices",
    defaultPhase = LifecyclePhase.PROCESS_CLASSES,
    requiresDependencyResolution = ResolutionScope.COMPILE_PLUS_RUNTIME)
public class MergeAdvicesMojo extends AbstractMojo {

  @Parameter(defaultValue = "${project}", readonly = true, required = true)
  private MavenProject project;

  @Parameter(defaultValue = "${project.build.outputDirectory}/META-INF", readonly = true)
  private File outputDirectory;

  @Parameter(property = "mergedAdviceAnnotations", defaultValue = "advice_annotations")
  private String adviceAnnotations;

  @Parameter(property = "mergedAdviceImplementation", defaultValue = "advice_implementations")
  private String adviceImplementations;

  public void execute() throws MojoExecutionException {
    getLog().info("==========================================");
    getLog().info("Starting advice file extraction and merge");
    getLog().info("==========================================");

    extracted(adviceAnnotations);
    extracted(adviceImplementations);

    getLog().info("==========================================");
    getLog().info("Advice merge completed successfully");
    getLog().info("==========================================");
  }

  private void extracted(String fileName) throws MojoExecutionException {
    // Extract and merge advice files
    StringBuilder mergedContent = new StringBuilder();
    int filesFound = 0;

    // First, scan the current module's resource directories
    int currentModuleCount = scanCurrentModuleResources(fileName, mergedContent);
    if (currentModuleCount > 0) {
      getLog().info("Found " + currentModuleCount + " advice file(s) in current module");
      filesFound += currentModuleCount;
    }

    // Then, scan all dependency JAR files
    List<File> jarFiles = collectDependencyJars();
    getLog().info("Found " + jarFiles.size() + " dependency JAR files to scan");

    for (File jarFile : jarFiles) {
      getLog().debug("Scanning JAR: " + jarFile.getName());
      try {
        int count = extractAdviceFiles(jarFile, fileName, mergedContent);
        if (count > 0) {
          getLog().info("Found " + count + " advice file(s) in " + jarFile.getName());
          filesFound += count;
        }
      } catch (IOException e) {
        getLog().warn("Failed to process JAR: " + jarFile.getAbsolutePath(), e);
      }
    }

    if (filesFound == 0) {
      getLog().warn("No advice files found in current module or dependencies!");
      return;
    }

    getLog().info("Total advice files found: " + filesFound);

    // Write merged content to output file
    writeMergedFile(mergedContent.toString(), fileName);
  }

  /**
   * Scans the current module's resource directories for advice files. Scans the output directory
   * (target/classes) which contains both: - Files copied from src/main/resources during
   * process-resources phase - Files generated by annotation processors during compile phase
   *
   * @return the number of advice files found in current module
   */
  private int scanCurrentModuleResources(String fileName, StringBuilder mergedContent) {
    int count = 0;

    // Scan the output directory (target/classes) where all resources end up
    // This includes both copied resources and annotation processor generated files
    if (outputDirectory != null && outputDirectory.exists() && outputDirectory.isDirectory()) {
      getLog()
          .debug("Scanning current module output directory: " + outputDirectory.getAbsolutePath());
      count += scanResourceDirectory(outputDirectory, fileName, mergedContent);
    }

    return count;
  }

  /**
   * Recursively scans a resource directory for advice files in META-INF.
   *
   * @return the number of advice files found
   */
  private int scanResourceDirectory(File directory, String fileName, StringBuilder mergedContent) {
    int count = 0;
    File metaInfDir = new File(directory, "META-INF");

    if (!metaInfDir.exists() || !metaInfDir.isDirectory()) {
      return 0;
    }

    File[] files = metaInfDir.listFiles();
    if (files == null) {
      return 0;
    }

    for (File file : files) {
      if (file.isFile() && file.getName().equals(fileName)) {
        getLog().debug("  - Extracting: META-INF/" + file.getName());

        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
          // Add a header comment to identify the source
          mergedContent
              .append("# Source: current-module -> META-INF/")
              .append(file.getName())
              .append(System.lineSeparator());

          String line;
          while ((line = reader.readLine()) != null) {
            mergedContent.append(line).append(System.lineSeparator());
          }

          // Add a separator between files
          mergedContent.append(System.lineSeparator());
          count++;

        } catch (IOException e) {
          getLog().warn("Failed to read META-INF/" + file.getName() + " from current module", e);
        }
      }
    }

    return count;
  }

  /** Collects all dependency JAR files from the project. */
  private List<File> collectDependencyJars() {
    List<File> jarFiles = new ArrayList<>();
    Set<Artifact> artifacts = project.getArtifacts();

    if (artifacts != null) {
      for (Artifact artifact : artifacts) {
        if ("jar".equals(artifact.getType()) && artifact.getFile() != null) {
          jarFiles.add(artifact.getFile());
        }
      }
    }

    return jarFiles;
  }

  /**
   * Extracts advice files from a single JAR file and appends to merged content.
   *
   * @return the number of advice files found in this JAR
   */
  private int extractAdviceFiles(File jarFile, String fileName, StringBuilder mergedContent)
      throws IOException {
    int count = 0;

    try (JarFile jar = new JarFile(jarFile)) {
      Enumeration<JarEntry> entries = jar.entries();

      while (entries.hasMoreElements()) {
        JarEntry entry = entries.nextElement();
        String entryName = entry.getName();

        // Check if the entry is in META-INF and starts with the specified prefix
        if (entryName.startsWith("META-INF/" + fileName) && !entry.isDirectory()) {
          getLog().debug("  - Extracting: " + entryName);

          try (InputStream is = jar.getInputStream(entry);
              BufferedReader reader = new BufferedReader(new InputStreamReader(is, UTF_8))) {

            // Add a header comment to identify the source
            mergedContent
                .append("# Source: ")
                .append(jarFile.getName())
                .append(" -> ")
                .append(entryName)
                .append(System.lineSeparator());

            String line;
            while ((line = reader.readLine()) != null) {
              mergedContent.append(line).append(System.lineSeparator());
            }

            // Add a separator between files
            mergedContent.append(System.lineSeparator());
            count++;

          } catch (IOException e) {
            getLog().warn("Failed to read " + entryName + " from " + jarFile.getName(), e);
          }
        }
      }
    }

    return count;
  }

  /** Writes the merged content to the output file. */
  private void writeMergedFile(String content, String fileName) throws MojoExecutionException {
    // Ensure output directory exists
    if (!outputDirectory.exists()) {
      if (!outputDirectory.mkdirs()) {
        throw new MojoExecutionException(
            "Failed to create output directory: " + outputDirectory.getAbsolutePath());
      }
    }

    File mergedFile = new File(outputDirectory, fileName);

    try {
      Files.writeString(
          mergedFile.toPath(), content, StandardOpenOption.CREATE, StandardOpenOption.APPEND);
      getLog().info("Merged advices written to: " + mergedFile.getAbsolutePath());
    } catch (IOException e) {
      throw new MojoExecutionException(
          "Failed to write merged file: " + mergedFile.getAbsolutePath(), e);
    }
  }
}
